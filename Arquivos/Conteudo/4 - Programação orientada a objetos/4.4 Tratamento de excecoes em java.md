# Tratamento de exce√ß√µes em Java

## Palavras Reservadas:

- try, catch, finally: Cada uma dessas palavras, juntas, definem blocos para o tratamento de exce√ß√µes.
- throws: Declara que um m√©todo pode lan√ßar uma ou v√°rias exce√ß√µes.
- throw: Lan√ßa explicitamente uma exception.

### ¬†Error üî∏
- Usado pela JVM, serve para indicar quando existe algum problema de recurso do programa, tornando a execu√ß√£o imposs√≠vel de continuar.
- O ‚ÄúErro‚Äù √© algo que n√£o pode mais ser tratado, ao contr√°rio da ‚ÄúExce√ß√£o‚Äù que trata seus erros, pois todas as subclasses de Exception (menos as subclasses RuntimeException) s√£o exce√ß√µes que obrigat√≥riamente devem ser tratadas.

###¬†Unchecked Exception üî∏
- Herdam da classe¬†*RuntimeException*¬†ou da classe¬†*Error*.
- O compilador n√£o verifica o c√≥digo para ver se a exce√ß√£o foi capturada ou declarada.
- Se uma exce√ß√£o n√£o-verificada ocorrer e n√£o tiver sido capturada, o programa terminar√° ou executar√° com resultados inesperados.
- Em geral, podem ser evitadas com uma codifica√ß√£o adequada.

### Checked Exception üî∏¬†
- As exce√ß√µes que s√£o herdadas da classe¬†*Exception*, mas n√£o de¬†*RuntimeException*.
- O compilador imp√µe um requisito do tipo "capturar ou declarar".
- O compilador verifica cada chamada de m√©todo e declara√ß√£o de m√©todo para determinar se o m√©todo lan√ßa (*throws*) exce√ß√µes verificadas.
- Se lan√ßar, o compilador assegura que a exce√ß√£o verificada √© capturada ou declarada em uma cl√°usula¬†*throws*.
- Caso n√£o capturada nem declarada, ocorre um erro de compila√ß√£o.

### Exception Personalizada üî∏¬†
- Programadores podem achar √∫til declarar suas pr√≥prias classes de exce√ß√£o.
- Essas Exceptions s√£o espec√≠ficas aos problemas que podem ocorrer quando outro programador empregar suas classes reutiliz√°veis.
- Uma nova classe de exce√ß√£o deve estender uma classe de exce√ß√£o existente que assegura que a classe pode ser utilizada com o mecanismo de tratamento de exce√ß√µes, logo essas Exce√ß√µes customizadas s√£o derivadas da classe Exception.
- *Importante*: Antes de criar a nossa pr√≥pria exce√ß√£o, √© recomendado verificar se j√° existe alguma exce√ß√£o na biblioteca Java que j√° nos forne√ßa o que precisamos. Afinal, n√£o queremos reinventar a roda!

###¬†Blocos try/catch/finally üî∏

#### `try`
- Regi√£o onde se encontra o c√≥digo que queremos verificar se ir√° ou n√£o lan√ßar uma exce√ß√£o.
- Caso ocorra uma exce√ß√£o em algum ponto, o restante do c√≥digo contido no bloco¬†*try*¬†n√£o ser√° executado.
- O bloco¬†*try*¬†n√£o pode ser declarado sozinho, por tanto, precisa estar seguido de um ou v√°rios blocos¬†*catch*¬†e/ou de um bloco¬†*finally*.

#### `catch`
- Regi√£o onde se encontra o poss√≠vel tratamento da exce√ß√£o. Isso significa que s√≥ ser√° executado caso o bloco¬†*try*¬†apresentar alguma exce√ß√£o.
- Recebe como argumento a classe ou subclasse da poss√≠vel exce√ß√£o.
- No seu escopo ficam as instru√ß√µes de como tratar essa exce√ß√£o.
- Pode haver mais de um bloco¬†*catch*, por√©m, ser√° executado apenas o primeiro bloco que identificar a exce√ß√£o.
- *Importante*: Caso voc√™ utilize mais de um¬†*catch*¬†e houver exce√ß√µes de uma mesma hierarquia de classes, certifique-se que a classe mais gen√©rica esteja como argumento do √∫ltimo¬†*catch*. Caso contr√°rio, qualquer exce√ß√£o sempre cair√° neste primeiro¬†*catch*, assim fazendo com que a exception mais espec√≠fica n√£o seja verificada.

#### `finally`
- Este bloco √© opcional, mas caso seja constru√≠do, quase sempre ser√° executado. (A menos que seja for√ßada sua parada, por exemplo, com um System.exit(0), no¬†*catch*)
- Dentro do bloco¬†*finally*, poder√° conter outros blocos¬†*try, catch,*¬†bem como outro¬†*finally*.

### Cl√°usulas throws e throw
#### throws

- Usada na assinatura do m√©todo.
- Necess√°ria apenas para exce√ß√µes checked.
- Informa ao chamador que este m√©todo pode lan√ßar uma das exce√ß√µes listadas no escopo do m√©todo. Isso obriga a fazer a captura dessa exception (*try-catch*) ou relan√ßar o¬†*throws*.

#### throw

- √â usada para lan√ßar explicitamente uma exce√ß√£o de um m√©todo ou de qualquer bloco de c√≥digo.
- Usada principalmente para lan√ßar exce√ß√µes personalizadas

##### Importante! 

- O fluxo de execu√ß√£o "normal" do programa para imediatamente apos a execu√ß√£o da cl√°usula¬†*throw*. O bloco¬†*try*¬†envolvente mais pr√≥ximo √© verificado para encontrar um bloco¬†*catch*¬†que corresponda ao tipo de exce√ß√£o.
- Caso encontre essa correspond√™ncia, o controlado √© transferido para esse bloco. Caso contr√°rio, o pr√≥ximo bloco¬†*try*¬†envolvente √© verificado e assim por diante.
- Outro caso, √© se nenhuma captura for encontrada, o manipulador da exce√ß√£o padr√£o interromper√° o programa.

<br>

## Hierarquia de exce√ß√µes

<img src="./img/10.jpg" alt="" width="850">

As exce√ß√µes em Java s√£o organizadas em uma hierarquia de classes. Todas as exce√ß√µes s√£o subclasses da classe Throwable. Dentro da classe Throwable, existem duas subclasses principais: Exception e Error.

- A classe Exception representa as exce√ß√µes que podem ser tratadas durante a execu√ß√£o do programa.
- A classe Error representa problemas que normalmente est√£o fora do controle do programador, como falta de mem√≥ria.
- Existem outras subclasses de Exception, como RuntimeException, que representam erros que podem ser evitados com uma codifica√ß√£o adequada.
- √â importante entender a hierarquia de exce√ß√µes para saber qual tipo de exce√ß√£o capturar e como trat√°-la corretamente.

### Exemplo de tratamento de exce√ß√µes:
<details>
<summary>C√≥digo</summary>

```java
public class Main {
    public static void main(String[] args) {
        try {
            // C√≥digo que pode gerar uma exce√ß√£o
            Scanner scanner = new Scanner(System.in);
            System.out.println("Digite um n√∫mero inteiro:");
            int numero = Integer.parseInt(scanner.nextLine());
            
            // Divis√£o por zero
            int resultado = 10 / 0;
            
            // ArrayIndexOutOfBoundsException
            int[] numeros = new int[5];
            numeros[10] = 2;
            
        } catch (NumberFormatException e) {
            // Tratamento para quando o usu√°rio n√£o digita um n√∫mero inteiro
            System.out.println("Erro: digite um n√∫mero inteiro v√°lido.");
            
        } catch (ArithmeticException e) {
            // Tratamento para quando ocorre uma divis√£o por zero
            System.out.println("Erro: divis√£o por zero.");
            
        } catch (ArrayIndexOutOfBoundsException e) {
            // Tratamento para quando se tenta acessar um √≠ndice inv√°lido de um array
            System.out.println("Erro: √≠ndice inv√°lido do array.");
            
        } catch (Exception e) {
            // Tratamento para qualquer outra exce√ß√£o n√£o prevista nos catches anteriores
            System.out.println("Erro desconhecido: " + e.getMessage());
            
        } finally {
            // Bloco que sempre √© executado, mesmo que ocorra uma exce√ß√£o ou n√£o
            System.out.println("Fim do programa.");
        }
    }
}
```

</details>

<br>

### Analise de cada caso de exce√ß√µes 

<details>
<summary>C√≥digo exemplo Unchecked exception</summary>

```java
package Tratamento_de_erros.unchecked_exceptions;

import javax.swing.*;

public class Main {

    public static void main(String[] args) {
        boolean continue_looping = true;

        do{
            String a = JOptionPane.showInputDialog("Numerador: ");
            String b = JOptionPane.showInputDialog("Denominador: ");

            //Tratando poss√≠vel Erro -> Caso usu√°rio digite algo diferente de um n√∫mero*/
            try {
                int resultado = Dividir(Integer.parseInt(a), Integer.parseInt(b));
                System.out.println("O resultado √©: " + resultado);
                continue_looping = false;
            }
            //tratando em caso usu√°rio digite String ao inv√©s de n√∫mero
            catch (NumberFormatException num){
                // Para ver a pila de erro da exception no console
                num.printStackTrace();

                //Exibindo mensagem na tela
                JOptionPane.showMessageDialog(null, "Erro! Aceitamos " +
                        "apenas n√∫meros inteiros " + num.getMessage());
            }
            //Tratando caso denominador = 0
            catch (ArithmeticException num_0){
                // Para ver a pila de erro da exception no console
                num_0.printStackTrace();

                //Exibindo mensagem na tela
                JOptionPane.showMessageDialog(null, "Erro! O " +
                        "denominador n√£o pode ser zero " + num_0.getMessage());
            }
            //Executado independe das condi√ß√µes acima
            finally {
                System.out.println("Chegou no finally!");
            }
        }while (continue_looping);

        System.out.println("O c√≥digo continua...");
    }

    public static int Dividir(int num_a, int num_b){
        return num_a/ num_b;
    }
}
```

</details>

<details>
<summary>C√≥digo exemplo checked exception</summary>

```java
package Checked_exception;

import javax.swing.*;
import java.io.*;

public class Main {
    public static void main(String[] args) {
        String nome_arquivo = "romances-Blake-Crouch.txt";
        try {
            ImprimirArquivoNoConsole(nome_arquivo);
        }
        //Tratando erro caso o arquivo n√£o esteja na raiz do projeto (Arquivo n√£o encontrado)
        catch (FileNotFoundException arq) {
            //Imprimindo pilha do erro no console
            arq.printStackTrace();

            //Mostrando erro para o usu√°rio
            JOptionPane.showMessageDialog(null,
                    "Erro! O documento que desenha imprimir n√£o foi encontrado " + arq.getCause());
        }
        //Tratando de "IOException" (Erro gen√©rico) -> Leitura, escrita ou impress√£o do documento
        catch (IOException arq){
            //Imprimindo pilha do erro no console
            arq.printStackTrace();

            //Mostrando erro para o usu√°rio
            JOptionPane.showMessageDialog(null,
                    "Ocorreu um erro inesperado. Procure o suporte." + arq.getCause());
        }
        //Opcional para executar independente de tratamento de erro ou execu√ß√£o de try
        finally {
            System.out.println("Chegou no bloco finally!");
        }

        System.out.println("Apesar da exception ou n√£o, o programa continua...");
    }

    //Com o "trows" eu jogo as exce√ß√µes a serem tratadas por quem chama o m√©todo "ImprimrirArquivoConsole"
    public static void ImprimirArquivoNoConsole(String nome_do_arqivo) throws IOException {
        File file = new File(nome_do_arqivo);

        BufferedReader br = new BufferedReader(new FileReader(file.getName()));
        String line = br.readLine();

        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        do{
            bw.write(line);
            bw.newLine();
            line= br.readLine();
        }while (line != null);
            bw.flush();
            br.close();
    }
}
```

</details>

<details>
<summary>C√≥digo exemplo custom exception</summary>

<details>
<summary>1¬∞ Estudo</summary>

```java
package Custom_Exception;

import javax.swing.*;
import java.io.*;

public class Main {
    public static void main(String[] args) {
        String nome_do_arquivo = JOptionPane.showInputDialog("Nome do arquivo a ser exibido: ");

        imprimirArquivoNoConsole(nome_do_arquivo);
        System.out.println("\nCom exception ou n√£o, o programa continua...");
    }

    public static void imprimirArquivoNoConsole(String nome_do_arquivo) {

        try {
            BufferedReader br = lerArquivo(nome_do_arquivo);
            String line = br.readLine();
            BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
            do {
                bw.write(line);
                bw.newLine();
                line = br.readLine();
            } while (line != null);
            bw.flush();
            br.close();
        }
        //Exception criada (Acionada para tratar erro de abertura de arquivo)
        catch (ImpossivelAberturaDeArquivoException element) {
            JOptionPane.showMessageDialog(null,
                    element.getMessage());
            //element.printStackTrace();
        } catch (IOException ex) {
            JOptionPane.showMessageDialog(null,
                    "Ocorreu um erro n√£o esperado, por favor, fale com o suporte." + ex.getMessage());
            ex.printStackTrace();
        }
    }

    public static BufferedReader lerArquivo(String nome_do_arquivo) throws ImpossivelAberturaDeArquivoException {

        File file = new File(nome_do_arquivo);
        try {
            return new BufferedReader(new FileReader(nome_do_arquivo));
        } catch (FileNotFoundException element) {
            throw new ImpossivelAberturaDeArquivoException(file.getName(), file.getPath());
        }
    }
}

class ImpossivelAberturaDeArquivoException extends Exception {
    private String nome_do_arquivo;
    private String diretorio;

    public ImpossivelAberturaDeArquivoException(String nome_do_arquivo, String diretorio) {
        super("O arquivo " + nome_do_arquivo + " n√£o foi encontrado no diret√≥rio " + diretorio);
        this.nome_do_arquivo = nome_do_arquivo;
        this.diretorio = diretorio;
    }

    /*@Override
    public String toString() {
        return "ImpossivelAberturaDeArquivoException{" +
                "nomeDoArquivo='" + nomeDoArquivo + '\'' +
                ", diretorio='" + diretorio + '\'' +
                '}';
    }*/

}
```

</details>

<details>
<summary>2¬∞ Estudo</summary>

```java
package Custom_Exception;

import javax.swing.*;

public class Main {
    public static void main(String[] args) {
        int[] numerador = {4,5,8,10};
        int[] denominador = {2,4,0,2,8};

        for (int i = 0; i< denominador.length; i++){
            try {
                if (numerador[i] % 2 != 0) {
                    throw new DivisaoNaoExataExecption("Divis√£o n√£o exata! ", numerador[i], denominador[i]);
                }
                int resultado = numerador[i] / denominador[i];
                System.out.println(resultado);
            }
            catch (DivisaoNaoExataExecption num) {
                //Mostrando a pilah de erro
                num.printStackTrace();

                //Mostrando mensagem para o usu√°rio
                JOptionPane.showMessageDialog(null, num.getMessage());

            }
        }
            System.out.println("O programa continua...");
    }
}
```

</details>


</details>

<br>

#### Refer√™ncia
[Cami-la exceptions-java](https://github.com/cami-la/exceptions-java/tree/master)<br>
[Documenta√ß√£o java](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Error.html)<br>
[Diagram of exception hierarchy](https://www.programcreek.com/2009/02/diagram-for-hierarchy-of-exception-classes/)<br>
[Dev midia trabalhando com excec√µes](https://www.devmedia.com.br/trabalhando-com-excecoes-em-java/27601)

<br>

<br>

<br>

[Voltar ao inicio](/README.md)