# Heran√ßa 

Heran√ßa √© um conceito fundamental na programa√ß√£o orientada a objetos que permite criar uma hierarquia de classes, onde uma classe filha herda os atributos e m√©todos de sua classe pai. Isso significa que uma classe filha pode aproveitar o comportamento e a funcionalidade da classe pai, al√©m de adicionar suas pr√≥prias caracter√≠sticas √∫nicas.

- Em Java, para definir uma classe filha que herda da classe pai, usamos a palavra-chave "extends". Por exemplo, considere a seguinte classe pai "Animal":
    ```java
    //Classe pai, classe m√£e ou superclasse "Animal"
    public class Animal {
        private String nome;
        private int idade;

        public Animal(String nome, int idade) {
            this.nome = nome;
            this.idade = idade;
        }

        public String getNome() {
            return nome;
        }

        public int getIdade() {
            return idade;
        }

        public void fazerSom() {
            System.out.println("O animal est√° fazendo som!");
        }
    }
    ```
<br>

- Agora, vamos criar uma classe filha "Cachorro" que herda de "Animal" e adiciona um m√©todo "latir":
- Observe que a classe filha "Cachorro" usa a palavra-chave "extends" para herdar de "Animal". Tamb√©m √© importante notar que a classe filha n√£o precisa definir novamente os atributos e m√©todos que j√° foram definidos na classe pai.
    ```java
    //Subclasse ou classe filho "Cachorro"
    public class Cachorro extends Animal {
        public Cachorro(String nome, int idade) {
            super(nome, idade);
        }

        public void latir() {
            System.out.println("O cachorro est√° latindo!");
        }
    }
    ```
<br>

- Agora, podemos criar uma inst√¢ncia da classe "Cachorro" e chamar seus m√©todos:

    > üí° Observe que a inst√¢ncia da classe **Cachorro** pode acessar os m√©todos **"getNome"** e **"getIdade"** da classe pai "Animal", bem como os m√©todos "fazerSom" e "latir" da classe filha **Cachorro**.


    ```java
    //Classe main
    public static void main(String[] args) {
        Cachorro cachorro = new Cachorro("Rex", 3);
        System.out.println(cachorro.getNome()); // Output: Rex
        System.out.println(cachorro.getIdade()); // Output: 3
        cachorro.fazerSom(); // Output: O animal est√° fazendo som!
        cachorro.latir(); // Output: O cachorro est√° latindo!
    }
    ```
<br>

## Tipos de heran√ßa 

### Heran√ßa simples:
Heran√ßa √© um recurso da programa√ß√£o orientada a objetos que permite criar novas classes a partir de outras classes j√° existentes, herdando seus atributos e m√©todos. A classe que √© herdada √© chamada de classe pai ou superclasse, e a classe que herda √© chamada de classe filha ou subclasse.

A heran√ßa simples √© quando uma classe filha herda atributos e m√©todos de uma √∫nica classe pai.

<details>
<summary>C√≥digo exemplo</summary>

```java
//Superclasse "Pessoa"
public class Pessoa {
    private String nome;
    private int idade;

    public Pessoa(String nome, int idade) {
        this.nome = nome;
        this.idade = idade;
    }

    public String getNome() {
        return nome;
    }

    public int getIdade() {
        return idade;
    }
}

//Subclasse "Aluno"
public class Aluno extends Pessoa {
    private String matricula;

    public Aluno(String nome, int idade, String matricula) {
        super(nome, idade);
        this.matricula = matricula;
    }

    public String getMatricula() {
        return matricula;
    }
}
```

</details>

<br>

### Heran√ßa m√∫ltipla:
√â quando uma classe filha herda atributos e m√©todos de duas ou mais classes pai. Em Java, a heran√ßa m√∫ltipla n√£o √© permitida diretamente, ou seja, uma classe n√£o pode herdar de mais de uma classe pai. Por√©m, podemos simular a heran√ßa m√∫ltipla utilizando interfaces.

Uma interface √© uma cole√ß√£o de m√©todos abstratos, que s√£o definidos mas n√£o implementados. Uma classe pode implementar uma ou mais interfaces, o que permite que ela tenha m√∫ltiplos comportamentos. Por exemplo:

<details>
<summary>C√≥digo Exemplo</summary>

```java
public interface Animal {
    void emitirSom();
}

public interface Voador {
    void voar();
}

public class Pato implements Animal, Voador {
    public void emitirSom() {
        System.out.println("Quack quack");
    }

    public void voar() {
        System.out.println("Voando...");
    }
}
/*Neste exemplo, temos duas interfaces, "Animal" e "Voador", que definem m√©todos abstratos 
"emitirSom" e "voar", respectivamente. A classe "Pato" implementa as duas interfaces, o que 
significa que ela tem o comportamento de um animal e o comportamento de um animal voador.*/
```

```java
public static void main(String[] args) {
    Pato pato = new Pato();
    pato.emitirSom(); // Output: Quack quack
    pato.voar(); // Output: Voando...
}

/*Podemos criar uma inst√¢ncia de "Pato" e chamar seus m√©todos: Neste exemplo, 
criamos um objeto "Pato" e chamamos seus m√©todos "emitirSom" e "voar". */
```

</details>

<br>

## Upcast e downcast
Em programa√ß√£o orientada a objetos, a heran√ßa √© uma rela√ß√£o entre classes na qual uma classe filha herda as propriedades e comportamentos da classe m√£e. Quando falamos de upcast e downcast, estamos nos referindo a como um objeto de uma classe √© tratado quando √© referenciado como um objeto de outra classe relacionada atrav√©s da hierarquia de heran√ßa.

`Upcast` 
Ocorre quando um objeto de uma subclasse √© tratado como um objeto de uma classe m√£e na hierarquia de heran√ßa. Isso pode ser feito implicitamente, sem a necessidade de um casting expl√≠cito. 

`downcast`
Ocorre quando um objeto de uma classe m√£e √© tratado como um objeto de uma subclasse na hierarquia de heran√ßa. Isso requer um casting expl√≠cito. Geralmente tentamos sempre evitar downcasts pois a subclasse pode conter atributos que n√£o tenhamos na superclasse. Assim, correremos risco de perda de dados. 

#### Representa√ß√£o:
<img src="./img/01.webp" alt="" width="600">

<br>

<details>
<summary>C√≥digo exemplo</summary>

```java
public class main{
    public static void main(String[] args) {
        Animal animal = new Cachorro(); // upcast
        animal.fazerBarulho(); // chama o m√©todo da subclasse
        //animal.correr(); // erro de compila√ß√£o: Animal n√£o tem o m√©todo correr()

        Cachorro cachorro = (Cachorro) animal; // downcast
        cachorro.fazerBarulho(); // chama o m√©todo da subclasse
        cachorro.correr(); // chama o m√©todo da subclasse
    }
}
```
```java
class Animal {
    public void fazerBarulho() {
        System.out.println("Fazendo barulho gen√©rico de animal");
    }
}
```

```java
class Cachorro extends Animal {
    public void fazerBarulho() {
        System.out.println("Au au!");
    }

    public void correr() {
        System.out.println("Cachorro correndo");
    }
}
```
</details>

<br>

## Polimorfismo vs sobescrita

### Polimorfismo
√â a capacidade de um objeto poder ser referenciado de v√°rias formas. Isso permite que um objeto de uma subclasse seja tratado como um objeto de sua classe pai. O polimorfismo permite escrever c√≥digo mais flex√≠vel e gen√©rico, aumentando a reutiliza√ß√£o de c√≥digo.

<details>
<summary>C√≥digo exemplo</summary>

```java
class Animal {
    public void emitirSom() {
        System.out.println("O animal emite um som.");
    }
}

class Cachorro extends Animal {
    @Override
    public void emitirSom() {
        System.out.println("O cachorro late.");
    }
}

class Gato extends Animal {
    @Override
    public void emitirSom() {
        System.out.println("O gato mia.");
    }
}

public class ExemploPolimorfismo {
    public static void main(String[] args) {
        Animal animal1 = new Cachorro();
        Animal animal2 = new Gato();

        animal1.emitirSom(); // Sa√≠da: O cachorro late.
        animal2.emitirSom(); // Sa√≠da: O gato mia.
    }
}
```

</details>

<br>

### Sobrescrita
√â um mecanismo que permite que uma subclasse forne√ßa sua pr√≥pria implementa√ß√£o para um m√©todo definido em sua classe pai. Quando um m√©todo √© sobrescrito em uma subclasse, o m√©todo na subclasse √© executado em vez do m√©todo na classe pai.

<details>
<summary>C√≥digo exemplo</summary>

```java
class Veiculo {
    public void acelerar() {
        System.out.println("O ve√≠culo est√° acelerando.");
    }
}

class Carro extends Veiculo {
    @Override
    public void acelerar() {
        System.out.println("O carro est√° acelerando rapidamente.");
    }
}

class Moto extends Veiculo {
    @Override
    public void acelerar() {
        System.out.println("A moto est√° acelerando velozmente.");
    }
}

public class ExemploSobrescrita {
    public static void main(String[] args) {
        Veiculo veiculo1 = new Carro();
        Veiculo veiculo2 = new Moto();

        veiculo1.acelerar(); // Sa√≠da: O carro est√° acelerando rapidamente.
        veiculo2.acelerar(); // Sa√≠da: A moto est√° acelerando velozmente.
    }
}
```

</details>


